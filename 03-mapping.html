<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>TIB2017: Análisis transcriptómicos</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="PBI - Transcriptomica" href="http://bi.ira.cinvestav.mx:8282/"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://bi.ira.cinvestav.mx:8282/" title="Posgrado en Biologia Integrativa">
          <img alt="Logo PBI" src="img/posgrado_bi_logo.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Análisis transcriptómicos</h1></a>
          <h2 class="subtitle">Alineamiento de lecturas</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="objetivos-de-aprendizaje"><span class="glyphicon glyphicon-certificate"></span>Objetivos de aprendizaje</h2>
</div>
<div class="panel-body">
<ul>
<li>Alinear datos de secuenciación a una referencia (genomas o transcriptomas)</li>
<li>Entender como interpretar datos de alineamiento de secuenciación masiva</li>
<li>Primer acercamiento a los formatos de coordenadas SAM y BAM</li>
</ul>
</div>
</section>
<section class="prereq panel panel-warning">
<div class="panel-heading">
<h2 id="datos-requeridos"><span class="glyphicon glyphicon-education"></span>Datos requeridos</h2>
</div>
<div class="panel-body">
<p>Para proceder con esta práctica, se requieren los resultados de tarea de ensamble de transcriptoma de la clase pasada:</p>
<ul>
<li>Archivos fastq de lecturas filtradas por calidad usando Trimmomatic via Trinity</li>
<li>Archivo fasta de ensamble de transcriptoma completo</li>
</ul>
</div>
</section>
<p>Usaremos los archivos fastq que utilizamos la clase pasada, pero filtrados por calidad por Trimmomatic via Trinity resultantes de su tarea. Estos se encuentran el en directorio <code>trinity_out_dir</code> con la extensión <code>*.qtrim.gz</code>.</p>
<p>Con lecturas en pares, habrá casos en los que ambas lecturas sean filtradas (P), y casos en los que una lectura se conservó y la otra se desechó (U). Las lecturas filtradas se encuentran en los siguientes archivos (ejemplo):</p>
<pre class="output"><code>reads.left.fq.gz.P.qtrim.gz     
reads.left.fq.gz.U.qtrim.gz
reads.right.fq.gz.P.qtrim.gz
reads.right.fq.gz.U.qtrim.gz</code></pre>
<p>También usaremos el genoma de referencia de nuestro organismo, <em>Saccharomyces pombe</em>:</p>
<pre class="output"><code>$ wget https://liz-fernandez.github.io/PBI_transcriptomics/datasets/genome/Sp_genome.fa</code></pre>
<p>Como ya sabemos, es buena idea primero ver que los datos están en el formato correcto. Para este ejercicio solo utilizaremos las lecturas que conservaron sus pares después de ser filtradas:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">for</span> <span class="kw">i</span> in trinity_out_dir/*.P.qtrim.gz <span class="kw">;</span> <span class="kw">do</span> <span class="kw">zcat</span> <span class="ot">$i</span> <span class="kw">|</span> <span class="kw">head</span> <span class="kw">;</span> <span class="kw">done</span> 
$ <span class="kw">ln</span> -s ./trinity_out_dir/*.P.qtrim.gz .</code></pre></div>
<p>Una vez que verificamos que las lecturas están el formato correcto, vamos a alinear las lecturas y transcritos al genoma utilizando Bowtie2 via TopHat.</p>
<p>Pueden encontrar el manual en el siguiente <a href="https://ccb.jhu.edu/software/tophat/manual.shtml">link</a>.</p>
<h2 id="mapeando-los-transcritos-al-genoma">Mapeando los transcritos al genoma</h2>
<p>En los casos en los que contamos con una referencia, es muy útil analizar los transcritos en su contexto genómico. En este ejercicio usaremos el programa de mapeo <a href="http://research-pub.gene.com/gmap/">GMAP</a>.</p>
<p>El primer paso para realizar el mapeo es generar el índice por medio del comando:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gmap_build</span> -d genome -D . -k 13 Sp_genome.fa</code></pre></div>
<pre class="output"><code>Sorting chromosomes in chrom order.  To turn off or sort other ways, use the -s flag.
Creating files in directory ./genome
Running &quot;/usr/local/bioconda/bin/fa_coords&quot;     -o &quot;./genome.coords&quot; -f &quot;./genome.sources&quot;
Opening file Sp_genome.fa
  Processed short contigs (&lt;1000000 nt): .
============================================================
Contig mapping information has been written to file ./genome.coords.
You should look at this file, and edit it if necessary
If everything is okay, you should proceed by running
    make gmapdb
============================================================
Running &quot;/usr/local/bioconda/bin/gmap_process&quot;  -c &quot;./genome.coords&quot; -f &quot;./genome.sources&quot; | &quot;/usr/local/bioconda/bin/gmapindex&quot;  -d genome -D &quot;./genome&quot; -A
Reading coordinates from file ./genome.coords
Logging contig genome at genome:1..451226 in genome genome
 =&gt; primary (linear) chromosome
Total genomic length = 451226 bp
Have a total of 1 chromosomes
Writing chromosome file ./genome/genome.chromosome
Chromosome genome has universal coordinates 1..451226
Writing chromosome IIT file ./genome/genome.chromosome.iit
Writing IIT file header information...coordinates require 4 bytes each...done
Processing null division/chromosome...sorting...writing...done (1 intervals)
Writing IIT file footer information...done
Writing IIT file header information...coordinates require 4 bytes each...done
Processing null division/chromosome...sorting...writing...done (1 intervals)
Writing IIT file footer information...done
No alternate scaffolds observed
Running &quot;/usr/local/bioconda/bin/gmap_process&quot;  -c &quot;./genome.coords&quot; -f &quot;./genome.sources&quot; | &quot;/usr/local/bioconda/bin/gmapindex&quot;  -d genome -F &quot;./genome&quot; -D &quot;./genome&quot; -G
Genome length is 451226 nt
Trying to allocate 42303*4 bytes of memory...succeeded.  Building genome in memory.
Reading coordinates from file ./genome.coords
Writing contig genome to universal coordinates 1..451226
A total of 0 non-ACGTNX characters were seen in the genome.
Running cat &quot;./genome/genome.genomecomp&quot; | &quot;/usr/local/bioconda/bin/gmapindex&quot; -d genome -U &gt; &quot;./genome/genome.genomebits128&quot;
Running cat &quot;./genome/genome.genomecomp&quot; | &quot;/usr/local/bioconda/bin/gmapindex&quot; -k 13 -q 3  -d genome -F &quot;./genome&quot; -D &quot;./genome&quot; -N
Counting positions in genome genome (13 bp every 3 bp), position 0
Number of offsets: 142909 =&gt; pages file not required
Running &quot;/usr/local/bioconda/bin/gmapindex&quot; -k 13 -q 3  -d genome -F &quot;./genome&quot; -D &quot;./genome&quot; -O  &quot;./genome/genome.genomecomp&quot;
Offset compression types: bitpack64
Allocating 1048576*1 bytes for packsizes
Allocating 1048576*8 bytes for bitpacks
Indexing offsets of oligomers in genome genome (13 bp every 3 bp), position 0
Writing 67108865 offsets compressed via bitpack64...done
Running &quot;/usr/local/bioconda/bin/gmapindex&quot; -k 13 -q 3  -d genome -F &quot;./genome&quot; -D &quot;./genome&quot; -P &quot;./genome/genome.genomecomp&quot;
Looking for index files in directory ./genome
  Pointers file is genome.ref133offsets64meta
  Offsets file is genome.ref133offsets64strm
  Positions file is genome.ref133positions
Expanding offsetsstrm into counters...done
Allocating 1983664 bytes for counterstrm
Trying to allocate 142909*4 bytes of memory for positions...succeeded.  Building positions in memory.
Indexing positions of oligomers in genome genome (13 bp every 3 bp), position 0
Writing 142909 genomic positions to file ./genome/genome.ref133positions ...
done
Running &quot;/usr/local/bioconda/bin/gmapindex&quot; -d genome -F &quot;./genome&quot; -D &quot;./genome&quot; -S
Genome length is 451226
Building suffix array
SACA_K called with n = 451227, K = 5, level 0
SACA_K called with n = 119713, K = 0, level 1
SACA_K called with n = 38268, K = 0, level 2
SACA_K called with n = 12495, K = 0, level 3
SACA_K called with n = 4066, K = 0, level 4
For indexsize 12, occupied 412801/16777216
Optimal indexsize = 12
Running &quot;/usr/local/bioconda/bin/gmapindex&quot; -d genome -F &quot;./genome&quot; -D &quot;./genome&quot; -L
Building LCP array
Writing temporary file for rank...done
Writing temporary file for permuted sarray...done
Found 178 exceptions
Byte-coding: 451049 values &lt; 255, 178 exceptions &gt;= 255 (0.0%)
Building DC array
Building child array
Byte-coding: 449732 values &lt; 255, 1495 exceptions &gt;= 255 (0.3%)
Writing file ./genome/genome.salcpchilddcdone</code></pre>
<p>Una vez generado el índice mapeamos los transcritos generados en la tarea al genoma:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gmap</span> -n 0 -D . -d genome trinity_out_dir/Trinity.fasta -f samse <span class="kw">&gt;</span> trinity_gmap.sam</code></pre></div>
<pre class="output"><code>GMAP version 2016-09-23 called with args: gmap.avx2 -n 0 -D . -d genome trinity_out_dir/Trinity.fasta -f samse
Checking compiler assumptions for SSE2: 6B8B4567 327B23C6 xor=59F066A1
Checking compiler assumptions for SSE4.1: -103 -58 max=198 =&gt; compiler zero extends
Checking compiler options for SSE4.2: 6B8B4567 __builtin_clz=1 __builtin_ctz=0 _mm_popcnt_u32=17 __builtin_popcount=17
Finished checking compiler assumptions
Pre-loading compressed genome (oligos)......done (169,212 bytes, 42 pages, 0.00 sec)
Pre-loading compressed genome (bits)......done (169,248 bytes, 42 pages, 0.00 sec)
Looking for index files in directory ./genome
  Pointers file is genome.ref133offsets64meta
  Offsets file is genome.ref133offsets64strm
  Positions file is genome.ref133positions
Offsets compression type: bitpack64
Allocating memory for ref offset pointers, kmer 13, interval 3...Attached new memory for ./genome/genome.ref133offsets64meta...done (8,388,624 bytes, 0.00 sec)
Allocating memory for ref offsets, kmer 13, interval 3...Attached new memory for ./genome/genome.ref133offsets64strm...done (1,983,840 bytes, 0.01 sec)
Pre-loading ref positions, kmer 13, interval 3......done (571,636 bytes, 0.00 sec)
Starting alignment
No paths found for TRINITY_DN52_c0_g1_i1
No paths found for TRINITY_DN134_c0_g1_i1
No paths found for TRINITY_DN155_c0_g1_i1
No paths found for TRINITY_DN162_c0_g1_i1
No paths found for TRINITY_DN184_c0_g1_i1
Processed 381 queries in 2.59 seconds (147.10 queries/sec)
Removed existing memory for shmid 42893319
Removed existing memory for shmid 42860549</code></pre>
<p>Si revisamos el resultado, es un archivo con coordenadas en un formato llamado SAM (Sequence Alignment/Map format). Veamos en que consiste este formato:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">more</span> trinity_gmap.sam</code></pre></div>
<h3 id="el-formato-sam">El formato SAM</h3>
<p>Veamos un ejemplo más pequeño de este formato. Supongamos que tenemos el siguiente alineamiento:</p>
<pre class="output"><code>Coor    12345678901234 5678901234567890123456789012345
ref AGCATGTTAGATAA**GATAGCTGTGCTAGTAGGCAGTCAGCGCCAT
+r001/1       TTAGATAAAGGATA*CTG
+r002        aaaAGATAA*GGATA
+r003      gcctaAGCTAA
+r004                    ATAGCT..............TCAGC
-r003                           ttagctTAGGC
-r001/2                                       CAGCGGCAT</code></pre>
<p>El formato SAM correspondiente será el siguiente:</p>
<pre class="output"><code>@HD VN:1.5  SO:coordinate
@SQ SN:ref  LN:45
r001    99  ref 7   30  8M2I4M1D3M  =   37  39  TTAGATAAAGGATACTG   *
r002    0   ref 9   30  3S6M1P1I4M  *   0   0   AAAAGATAAGGATA  *
r003    0   ref 9   30  5S6M    *   0   0   GCCTAAGCTAA *   SA:Z:ref,29,-,6H5M,17,0;
r004    0   ref 16  30  6M14N5M *   0   0   ATAGCTTCAGC *
r003    2064    ref 29  17  6H5M    *   0   0   TAGGC   *   SA:Z:ref,9,+,5S6M,30,1;
r001    147 ref 37  30  9M  =   7   -39 CAGCGGCAT   *   NM:i:1</code></pre>
<p>El formato SAM es un formato de texto plano que nos permite guardar datos de secuenciación en formato ASCII delimitado por tabulaciones.</p>
<p>Está compuesto de dos secciones principales:</p>
<ul>
<li>El encabezado</li>
<li>El alineamiento</li>
</ul>
<p>La sección del <strong>encabezado</strong> comienza con el caracter <code>@</code> seguido por uno de lo códigos de dos letras que sirven para características de los alineamientos en este archivo. Cada línea esta delimitada por tabulaciones y, además de las líneas que comienzan con <code>@CO</code>, cada campo de datos tiene el formato <code>TAG:VALUE</code>, en donde <code>TAG</code> es una cadena de dos caracteres que define el formato y contenido de <code>VALUE</code>.</p>
<p>El encabezado no es indispensable pero contiene información acerca de la versión del archivo así como si está ordenado o no. Por ello es recomendable incluirlo.</p>
<p>La sección de <strong>alineamiento</strong> contiene la siguiente información:</p>
<ol style="list-style-type: decimal">
<li><strong>QNAME</strong> Nombre de la referencia, QNAME (SAM)/Nombre de la lectura(BAM). Se utiliza para agrupar alineamientos que están juntos, como es el caso de alineamientos de lecturas por pares o una lectura que aparece en alineamientos múltiples.</li>
<li><strong>FLAG</strong> Set de información describiendo el alineamiento. Provee la siguiente información:
<ul>
<li>¿Hay múltiples fragmentos?</li>
<li>¿Todos los fragmentos están bien alineados?</li>
<li>¿Está alineado este fragmento?</li>
<li>¿No ha sido alineado el siguiente fragmento?</li>
<li>¿Es esta referencia la cadena inversa?</li>
<li>¿El el siguiente fragmento la cadena reversa?</li>
<li>¿Es este el primer fragmento?</li>
<li>¿Es este el último fragmento?</li>
<li>¿Es este un alineamiento secundario?</li>
<li>¿Esta lectura falló los filtros de calidad?</li>
<li>¿Es esta lectura un duplicado por PCR o óptico?</li>
</ul></li>
<li><strong>RNAME</strong> Nombre de la secuencia de referencia.</li>
<li><strong>POS</strong> Posición de alineamiento izquierda (base 1).</li>
<li><strong>MAPQ</strong> Calidad del alineamiento.</li>
<li><strong>CIGAR</strong> cadena CIGAR.</li>
<li><strong>RNEXT</strong> Nombre de referencia del par (mate) o la siguiente lectura.</li>
<li><strong>PNEXT</strong> Posición del par (mate) o la siguiente lectura.</li>
<li><strong>TLEN</strong> Longitud del alineamiento.</li>
<li><strong>SEQ</strong> La secuencia de prueba de este alineamiento (en este caso la secuencia de la lectura).</li>
<li><strong>QUAL</strong> La calidad de la lectura.</li>
<li><strong>TAGs</strong> Información adicional.</li>
</ol>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="cadenas-cigar"><span class="glyphicon glyphicon-pushpin"></span>Cadenas CIGAR</h2>
</div>
<div class="panel-body">
<p>La secuencia alineada a la referencia puede tener bases adicionales que no están en la referencia o puede no tener bases en la lectura que si están en la referencial. La cadena CIGAR es una cadena que codifica cada base y la caracteristica de cada una en el alineamiento.</p>
<p>Por ejemplo, la cadena CIGAR:</p>
<pre class="output"><code>CIGAR: 3M1I3M1D5M</code></pre>
<p>indica que las primera 3 bases de la lectura alinea con la referencia (3M), la siguiente base no existe en la referencia (1I), las siguientes 3 bases alinean con la referencia (3M), la siguiente base no existe en la lectura (1D), y 5 bases más alinean con la referencia (5M).</p>
</div>
</aside>
<p>Como pueden ver estos archivos contienen muchísima información que puede ser analizada usando scripts que arrojen estadísticas del alineamiento. Programas como <a href="http://broadinstitute.github.io/picard/">Picard</a> realizan este tipo de análisis.</p>
<p>La versión comprimida de los archivos tipo SAM se conoce como BAM (binary sam). Convirtamos el archivo SAM a BAM usando samtools:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">samtools</span> view -Sb trinity_gmap.sam <span class="kw">&gt;</span> trinity_gmap.bam</code></pre></div>
<pre class="output"><code>[samopen] SAM header is present: 1 sequences.</code></pre>
<p>No abriremos este archivo ya que, dado que esta en formato binario, es ilegible. Sin embargo, tenemos que realizar dos últimos pasos visualizar los resultados:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">samtools</span> sort trinity_gmap.bam trinity_gmap
$ <span class="kw">samtools</span> index trinity_gmap.bam</code></pre></div>
<p>El primer paso ordena los resultados por sus coordenadas y el segundo crea índices para hacer más rápida la visualización usando un navegador. Visualizaremos esto datos en la próxima clase.</p>
<h2 id="mapeando-las-lecturas-filtradas-al-genoma">Mapeando las lecturas filtradas al genoma</h2>
<p>Primero generaremos un índice de bowtie2 para el genoma:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">bowtie2-build</span> Sp_genome.fa Sp_genome </code></pre></div>
<pre class="output"><code>Settings:
  Output files: &quot;Sp_genome.*.bt2&quot;
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Max bucket size: default
  Max bucket size, sqrt multiplier: default
  Max bucket size, len divisor: 4
  Difference-cover sample period: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Sp_genome.fa
Building a SMALL index
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
bmax according to bmaxDivN setting: 107781
Using parameters --bmax 80836 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 80836 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 71853.5 (target: 80835)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering Ebwt loop
Getting block 1 of 6
  Reserving size (80836) for bucket 1
  Calculating Z arrays for bucket 1
  Entering block accumulator loop for bucket 1:
  bucket 1: 10%
  bucket 1: 20%
  bucket 1: 30%
  bucket 1: 40%
  bucket 1: 50%
  bucket 1: 60%
  bucket 1: 70%
  bucket 1: 80%
  bucket 1: 90%
  bucket 1: 100%
  Sorting block of length 79345 for bucket 1
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 79346 for bucket 1
Getting block 2 of 6
  Reserving size (80836) for bucket 2
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 2:
  bucket 2: 10%
  bucket 2: 20%
  bucket 2: 30%
  bucket 2: 40%
  bucket 2: 50%
  bucket 2: 60%
  bucket 2: 70%
  bucket 2: 80%
  bucket 2: 90%
  bucket 2: 100%
  Sorting block of length 78903 for bucket 2
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 78904 for bucket 2
Getting block 3 of 6
  Reserving size (80836) for bucket 3
  Calculating Z arrays for bucket 3
  Entering block accumulator loop for bucket 3:
  bucket 3: 10%
  bucket 3: 20%
  bucket 3: 30%
  bucket 3: 40%
  bucket 3: 50%
  bucket 3: 60%
  bucket 3: 70%
  bucket 3: 80%
  bucket 3: 90%
  bucket 3: 100%
  Sorting block of length 73828 for bucket 3
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 73829 for bucket 3
Getting block 4 of 6
  Reserving size (80836) for bucket 4
  Calculating Z arrays for bucket 4
  Entering block accumulator loop for bucket 4:
  bucket 4: 10%
  bucket 4: 20%
  bucket 4: 30%
  bucket 4: 40%
  bucket 4: 50%
  bucket 4: 60%
  bucket 4: 70%
  bucket 4: 80%
  bucket 4: 90%
  bucket 4: 100%
  Sorting block of length 70864 for bucket 4
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 70865 for bucket 4
Getting block 5 of 6
  Reserving size (80836) for bucket 5
  Calculating Z arrays for bucket 5
  Entering block accumulator loop for bucket 5:
  bucket 5: 10%
  bucket 5: 20%
  bucket 5: 30%
  bucket 5: 40%
  bucket 5: 50%
  bucket 5: 60%
  bucket 5: 70%
  bucket 5: 80%
  bucket 5: 90%
  bucket 5: 100%
  Sorting block of length 74487 for bucket 5
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 74488 for bucket 5
Getting block 6 of 6
  Reserving size (80836) for bucket 6
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 6:
  bucket 6: 10%
  bucket 6: 20%
  bucket 6: 30%
  bucket 6: 40%
  bucket 6: 50%
  bucket 6: 60%
  bucket 6: 70%
  bucket 6: 80%
  bucket 6: 90%
  bucket 6: 100%
  Sorting block of length 53694 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 53695 for bucket 6
Exited Ebwt loop
fchr[A]: 0
fchr[C]: 135086
fchr[G]: 215577
fchr[T]: 296650
fchr[$]: 431126
Exiting Ebwt::buildToDisk()
Returning from initFromVector
Wrote 4340604 bytes to primary EBWT file: Sp_genome.1.bt2
Wrote 107788 bytes to secondary EBWT file: Sp_genome.2.bt2
Re-opening _in1 and _in2 as input streams
Returning from Ebwt constructor
Headers:
    len: 431126
    bwtLen: 431127
    sz: 107782
    bwtSz: 107782
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 20
    eftabSz: 80
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 26946
    offsSz: 107784
    lineSz: 64
    sideSz: 64
    sideBwtSz: 48
    sideBwtLen: 192
    numSides: 2246
    numLines: 2246
    ebwtTotLen: 143744
    ebwtTotSz: 143744
    color: 0
    reverse: 0
Total time for call to driver() for forward index: 00:00:00
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to reverse reference sequence: 00:00:00
bmax according to bmaxDivN setting: 107781
Using parameters --bmax 80836 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 80836 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 53889.9 (target: 80835)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering Ebwt loop
Getting block 1 of 8
  Reserving size (80836) for bucket 1
  Calculating Z arrays for bucket 1
  Entering block accumulator loop for bucket 1:
  bucket 1: 10%
  bucket 1: 20%
  bucket 1: 30%
  bucket 1: 40%
  bucket 1: 50%
  bucket 1: 60%
  bucket 1: 70%
  bucket 1: 80%
  bucket 1: 90%
  bucket 1: 100%
  Sorting block of length 41923 for bucket 1
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 41924 for bucket 1
Getting block 2 of 8
  Reserving size (80836) for bucket 2
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 2:
  bucket 2: 10%
  bucket 2: 20%
  bucket 2: 30%
  bucket 2: 40%
  bucket 2: 50%
  bucket 2: 60%
  bucket 2: 70%
  bucket 2: 80%
  bucket 2: 90%
  bucket 2: 100%
  Sorting block of length 79784 for bucket 2
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 79785 for bucket 2
Getting block 3 of 8
  Reserving size (80836) for bucket 3
  Calculating Z arrays for bucket 3
  Entering block accumulator loop for bucket 3:
  bucket 3: 10%
  bucket 3: 20%
  bucket 3: 30%
  bucket 3: 40%
  bucket 3: 50%
  bucket 3: 60%
  bucket 3: 70%
  bucket 3: 80%
  bucket 3: 90%
  bucket 3: 100%
  Sorting block of length 45293 for bucket 3
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 45294 for bucket 3
Getting block 4 of 8
  Reserving size (80836) for bucket 4
  Calculating Z arrays for bucket 4
  Entering block accumulator loop for bucket 4:
  bucket 4: 10%
  bucket 4: 20%
  bucket 4: 30%
  bucket 4: 40%
  bucket 4: 50%
  bucket 4: 60%
  bucket 4: 70%
  bucket 4: 80%
  bucket 4: 90%
  bucket 4: 100%
  Sorting block of length 39705 for bucket 4
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 39706 for bucket 4
Getting block 5 of 8
  Reserving size (80836) for bucket 5
  Calculating Z arrays for bucket 5
  Entering block accumulator loop for bucket 5:
  bucket 5: 10%
  bucket 5: 20%
  bucket 5: 30%
  bucket 5: 40%
  bucket 5: 50%
  bucket 5: 60%
  bucket 5: 70%
  bucket 5: 80%
  bucket 5: 90%
  bucket 5: 100%
  Sorting block of length 51531 for bucket 5
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 51532 for bucket 5
Getting block 6 of 8
  Reserving size (80836) for bucket 6
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 6:
  bucket 6: 10%
  bucket 6: 20%
  bucket 6: 30%
  bucket 6: 40%
  bucket 6: 50%
  bucket 6: 60%
  bucket 6: 70%
  bucket 6: 80%
  bucket 6: 90%
  bucket 6: 100%
  Sorting block of length 49697 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 49698 for bucket 6
Getting block 7 of 8
  Reserving size (80836) for bucket 7
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 7:
  bucket 7: 10%
  bucket 7: 20%
  bucket 7: 30%
  bucket 7: 40%
  bucket 7: 50%
  bucket 7: 60%
  bucket 7: 70%
  bucket 7: 80%
  bucket 7: 90%
  bucket 7: 100%
  Sorting block of length 77916 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 77917 for bucket 7
Getting block 8 of 8
  Reserving size (80836) for bucket 8
  Calculating Z arrays for bucket 8
  Entering block accumulator loop for bucket 8:
  bucket 8: 10%
  bucket 8: 20%
  bucket 8: 30%
  bucket 8: 40%
  bucket 8: 50%
  bucket 8: 60%
  bucket 8: 70%
  bucket 8: 80%
  bucket 8: 90%
  bucket 8: 100%
  Sorting block of length 45270 for bucket 8
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 45271 for bucket 8
Exited Ebwt loop
fchr[A]: 0
fchr[C]: 135086
fchr[G]: 215577
fchr[T]: 296650
fchr[$]: 431126
Exiting Ebwt::buildToDisk()
Returning from initFromVector
Wrote 4340604 bytes to primary EBWT file: Sp_genome.rev.1.bt2
Wrote 107788 bytes to secondary EBWT file: Sp_genome.rev.2.bt2
Re-opening _in1 and _in2 as input streams
Returning from Ebwt constructor
Headers:
    len: 431126
    bwtLen: 431127
    sz: 107782
    bwtSz: 107782
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 20
    eftabSz: 80
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 26946
    offsSz: 107784
    lineSz: 64
    sideSz: 64
    sideBwtSz: 48
    sideBwtLen: 192
    numSides: 2246
    numLines: 2246
    ebwtTotLen: 143744
    ebwtTotSz: 143744
    color: 0
    reverse: 1
Total time for backward call to driver() for mirror index: 00:00:00</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span> *bt2</code></pre></div>
<pre class="output"><code>Sp_genome.1.bt2        
Sp_genome.2.bt2              
Sp_genome.3.bt2       
Sp_genome.4.bt2           
Sp_genome.rev.1.bt2          
Sp_genome.rev.2.bt2</code></pre>
<p>Creamos hiperlinks para los archivos pareados en nuestro directorio local: <sub>~</sub> {.bash} $ ln -s ./trinity_out_dir/*P.qtrim.gz . <sub>~</sub></p>
<p>Usamos tophat2 para mapear las lecturas. Este programa nos permite dividir lecturas que atraviesan sitios de splicing:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tophat2</span> -I 300 -i 20 Sp_genome \
 Sp_log.left.fq.gz.P.qtrim.gz,Sp_hs.left.fq.gz.P.qtrim.gz,Sp_ds.left.fq.gz.P.qtrim.gz,Sp_plat.left.fq.gz.P.qtrim.gz \
 Sp_log.right.fq.gz.P.qtrim.gz,Sp_hs.right.fq.gz.P.qtrim.gz,Sp_ds.right.fq.gz.P.qtrim.gz,Sp_plat.right.fq.gz.P.qtrim.gz</code></pre></div>
<pre class="output"><code>[2017-01-24 13:53:23] Beginning TopHat run (v2.1.1)
-----------------------------------------------
[2017-01-24 13:53:23] Checking for Bowtie
          Bowtie version:    2.2.8.0
[2017-01-24 13:53:23] Checking for Bowtie index files (genome)..
[2017-01-24 13:53:23] Checking for reference FASTA file
[2017-01-24 13:53:23] Generating SAM header for Sp_genome
[2017-01-24 13:53:23] Preparing reads
     left reads: min. length=25, max. length=68, 329455 kept reads (431 discarded)
    right reads: min. length=25, max. length=68, 329725 kept reads (161 discarded)
[2017-01-24 13:53:31] Mapping left_kept_reads to genome Sp_genome with Bowtie2
[2017-01-24 13:53:44] Mapping left_kept_reads_seg1 to genome Sp_genome with Bowtie2 (1/2)
[2017-01-24 13:53:44] Mapping left_kept_reads_seg2 to genome Sp_genome with Bowtie2 (2/2)
[2017-01-24 13:53:44] Mapping right_kept_reads to genome Sp_genome with Bowtie2
[2017-01-24 13:53:57] Mapping right_kept_reads_seg1 to genome Sp_genome with Bowtie2 (1/2)
[2017-01-24 13:53:57] Mapping right_kept_reads_seg2 to genome Sp_genome with Bowtie2 (2/2)
[2017-01-24 13:53:57] Searching for junctions via segment mapping
    Coverage-search algorithm is turned on, making this step very slow
    Please try running TopHat again with the option (--no-coverage-search) if this step takes too much time or memory.
[2017-01-24 13:54:02] Retrieving sequences for splices
[2017-01-24 13:54:02] Indexing splices
Building a SMALL index
[2017-01-24 13:54:02] Mapping left_kept_reads_seg1 to genome segment_juncs with Bowtie2 (1/2)
[2017-01-24 13:54:02] Mapping left_kept_reads_seg2 to genome segment_juncs with Bowtie2 (2/2)
[2017-01-24 13:54:02] Joining segment hits
[2017-01-24 13:54:03] Mapping right_kept_reads_seg1 to genome segment_juncs with Bowtie2 (1/2)
[2017-01-24 13:54:03] Mapping right_kept_reads_seg2 to genome segment_juncs with Bowtie2 (2/2)
[2017-01-24 13:54:03] Joining segment hits
[2017-01-24 13:54:04] Reporting output tracks
-----------------------------------------------
[2017-01-24 13:54:30] A summary of the alignment counts can be found in ./tophat_out/align_summary.txt
[2017-01-24 13:54:30] Run complete: 00:01:07 elapsed</code></pre>
<p>Exploramos el resultado, el cuál es un archivo tipo SAM.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">samtools</span> view tophat_out/accepted_hits.bam <span class="kw">|</span> <span class="kw">head</span></code></pre></div>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="reto---alineando-las-lecturas-filtradas-al-transcriptoma"><span class="glyphicon glyphicon-pencil"></span>Reto - Alineando las lecturas filtradas al transcriptoma</h2>
</div>
<div class="panel-body">
<p>Hemos alineado las lecturas al genoma pero queremos alinearlas también directamente al transcriptoma. La vamos a revisar el manual de TopHat2 y usar las opciones que nos permite mapear lecturas directamente a transcriptomas.</p>
<ul>
<li><strong>Pista:</strong> No podrán utilizar el índice generado previamente.</li>
</ul>
<h3 id="solución">Solución</h3>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">bowtie2-build</span> Trinity.fasta Trinity_assembly_Sp
$ <span class="kw">tophat2</span> -I 300 -i 20 Trinity_assembly_Sp Sp_ds.left.fq.gz.P.qtrim.gz,Sp_hs.left.fq.gz.P.qtrim.gz,Sp_log.left.fq.gz.P.qtrim.gz,Sp_plat.left.fq.gz.P.qtrim.gz Sp_ds.right.fq.gz.P.qtrim.gz,Sp_hs.right.fq.gz.P.qtrim.gz,Sp_log.right.fq.gz.P.qtrim.gz,Sp_plat.right.fq.gz.P.qtrim.gz</code></pre></div>
</div>
</section>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="mailto:selene.fernandez.valverde@gmail.com">Contacto</a>
        <a class="label swc-blue-bg" href="LICENSE.html">Licencia</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
